<!DOCTYPE html>
<html lang="en">
<link href="https://fonts.googleapis.com/css?family=Lato:300,400,400i,700,700i" rel="stylesheet">
<body>
<div id=app></div>
<script src="/bundle.js" type="text/javascript"></script>
<textarea rows=5 cols="80" id=msg></textarea>
<button type=button onclick='host()'>Publish</button>

<p>To share the message with others, point them to http://localhost:3000/#<span id=roomId></span></p>

<script>
var websocket = new WebSocket('ws://' + window.location.hostname + ':' + window.location.port + '/connect'),
  RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection || window.msRTCPeerConnection,
  RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.msRTCSessionDescription,
  RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate || window.msRTCIceCandidate,
  rtcpeerconn = new RTCPeerConnection(
    {iceServers: [{ 'url': 'stun:stun.services.mozilla.com'}, {'url': 'stun:stun.l.google.com:19305'}]},
    {optional: [{RtpDataChannels: false}]}
  ),
  rtcdatachannel,
  roomId, clientId, // TODO: doesn't support multiple clients correctly
  hosting,
  comready, onerror;

window.host = function() {
  websocket.send(JSON.stringify({
    inst: 'host'
  }));
}

rtcpeerconn.ondatachannel = function(event) {
  rtcdatachannel = event.channel;
  rtcdatachannel.onopen = comready;
  rtcdatachannel.onerror = onerror;
};

websocket.onmessage = function(input) {
  var message = JSON.parse(input.data);
  if (message.inst === 'hosting') {
    roomId = message.roomId;
    hosting = true;
    document.getElementById('roomId').textContent = message.roomId;
  }
            if(message.type && message.type === 'join') {
              clientId = message.clientId;
                var offer = new RTCSessionDescription(message.offer);

                rtcpeerconn.setRemoteDescription(offer, function() {
                    rtcpeerconn.createAnswer(function(answer) {
                        rtcpeerconn.setLocalDescription(answer, function() {
                            var output = answer.toJSON();
                            if(typeof output === 'string') output = JSON.parse(output); // normalize: RTCSessionDescription.toJSON returns a json str in FF, but json obj in Chrome

                            websocket.send(JSON.stringify({
                                inst: 'send',
                                roomId: roomId,
                                clientId: clientId,
                                message: output
                            }));
                        }, onerror);
                    }, onerror);
                }, onerror);
            } else if(message.type && message.type === 'answer') {
                var answer = new RTCSessionDescription(message);
                rtcpeerconn.setRemoteDescription(answer, function() {/* handler required but we have nothing to do */}, onerror);
            } else if(rtcpeerconn.remoteDescription && message.candidate) {
                // ignore ice candidates until remote description is set
                rtcpeerconn.addIceCandidate(new RTCIceCandidate(message.candidate));
            }
}

rtcpeerconn.onicecandidate = function (event) {
  if (!event || !event.candidate) return;
  websocket.send(JSON.stringify({
    inst: 'send',
    roomId: roomId,
    clientId: clientId,
    message: {candidate: event.candidate}
  }));
};

/** called when RTC signaling is complete and RTCDataChannel is ready */
comready = function() {
  rtcdatachannel.onmessage = function(event) {
    document.getElementById('msg').value = event.data;
  }
  if (hosting) {
    rtcdatachannel.send(document.getElementById('msg').value);
  }
};

onerror = websocket.onerror = function(e) {
    console.log('====== WEBRTC ERROR ======', arguments);
    throw new Error(e);
};

if (window.location.hash.length > 1) {
  roomId = window.location.hash.slice(1);
  rtcdatachannel = rtcpeerconn.createDataChannel('textdrop');
  rtcdatachannel.onopen = comready;
  rtcdatachannel.onerror = onerror;

  rtcpeerconn.createOffer(function(offer) {
    rtcpeerconn.setLocalDescription(offer, function() {
      var output = offer.toJSON();
      if(typeof output === 'string') output = JSON.parse(output); // normalize: RTCSessionDescription.toJSON returns a json str in FF, but json obj in Chrome

      websocket.send(JSON.stringify({
        inst: 'join',
        roomId: roomId,
        message: output
      }));
    }, onerror);
  }, onerror);
}
</script>
